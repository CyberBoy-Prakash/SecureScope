import sys
import xml.etree.ElementTree as ET
import argparse
from bs4 import BeautifulSoup  # Required for parsing HTML
import os

def calculate_score(counts):
    # Define scores for each vulnerability severity
    scores = {
        'Critical': 5.0,
        'High': 4.0,
        'Medium': 3.0,
        'Low': 2.0,
        'Info': 1.5
    }

    total_score = 0.0

    # Calculate total score based on vulnerability counts
    for severity, count in counts.items():
        total_score += scores[severity] * count

    # Calculate the score out of 12.5
    max_score = sum(scores.values())  # Maximum possible score
    score_percentage = (total_score / max_score) * 100 if max_score != 0 else 0
    final_score = (score_percentage / 100) * 12.5  # Scaling to a score out of 12.5

    return final_score


def parse_html_report(html_path):
    try:
        with open(html_path, 'r', encoding='utf-8') as file:
            html_content = file.read()
    except FileNotFoundError:
        return "HTML file not found."

    soup = BeautifulSoup(html_content, 'html.parser')
    
    # Initialize counts and scores for each severity level
    severity_scores = {
        "Critical": 5,
        "High": 4,
        "Medium": 3,
        "Low": 2,
        "Info": 1
    }
    
    counts = {
        "Critical": 0,
        "High": 0,
        "Medium": 0,
        "Low": 0,
        "Info": 0
    }
    
    # Count occurrences of each severity level based on actual HTML structure
    for severity_level in counts.keys():
        elements = soup.find_all(string=severity_level)
        counts[severity_level] = len(elements)

    # Calculate total weighted score
    total_weighted_score = sum(count * severity_scores[level] for level, count in counts.items())
    
    # Calculate the maximum possible score based on counts
    max_possible_score = sum(counts.values()) * severity_scores["Critical"]  # Assuming Critical is the highest score
    
    # Normalize the total weighted score out of 12.5
    if max_possible_score > 0:
        normalized_score_out_of_12_5 = (total_weighted_score / max_possible_score) * 12.5
        return normalized_score_out_of_12_5
    else:
        return 0.0


# Function to extract vulnerability variables from XML
def extract_vulnerability_variables(issue):
    vulnerability_variables = {}
    vulnerability_variables['name'] = issue.find('name').text
    vulnerability_variables['severity'] = issue.find('severity').text
    vulnerability_variables['confidence'] = issue.find('confidence').text
    return vulnerability_variables

# Function to get score based on severity and confidence
def get_score(severity, confidence):
    scores = {
        'High': {'Certain': 5.0, 'Firm': 4.50, 'Tentative': 3.50, 'Total': 25.00},
        'Medium': {'Certain': 4.0, 'Firm': 3.50, 'Tentative': 2.50, 'Total': 19.00},
        'Low': {'Certain': 3.0, 'Firm': 2.50, 'Tentative': 1.50, 'Total': 13.00},
        'Information': {'Certain': 1.0, 'Firm': 0.50, 'Tentative': 0.25, 'Total': 1.75}
    }
    return scores[severity][confidence]

# Function to parse XML report
def parse_xml_report(xml_path):
    tree = ET.parse(xml_path)
    root = tree.getroot()

    scores_per_severity = {'High': 0.0, 'Medium': 0.0, 'Low': 0.0, 'Information': 0.0}
    count_per_severity = {'High': 0, 'Medium': 0, 'Low': 0, 'Information': 0}
    total_score = 0.0
    max_score = 0.0

    with open('score.txt', 'w') as file:
        for issue in root.findall('.//issue'):
            vulnerability_variables = extract_vulnerability_variables(issue)

            file.write("Vulnerability Variables:\n")
            for key, value in vulnerability_variables.items():
                file.write(f"{key}: {value}\n")

            severity = vulnerability_variables['severity']
            confidence = vulnerability_variables['confidence']

            try:
                score = get_score(severity, confidence)
                total_score += score
                max_score += 5.0
                scores_per_severity[severity] += score
                count_per_severity[severity] += 1
                file.write(f"The score for {severity} severity and {confidence} confidence is: {score}\n")
            except KeyError:
                pass

            file.write("\n")

        total_score_percent = (total_score / max_score) * 100 if max_score != 0 else 0

        file.write("------------------------------------------------------------------------------\n")
        file.write(f"Total Score: {total_score:.2f}/{max_score}\n")
        file.write("------------------------------------------------------------------------------\n")

        for severity, score in scores_per_severity.items():
            count = count_per_severity[severity]
            file.write(f"Severity: {severity}, Score: {score:.2f}, Count: {count}\n")

    return format(total_score_percent / 8, ".2f")

# Updated get_report function to include report_type
def get_report(report_path, report_type=None):
    if report_type == 'burp':
        return parse_xml_report(report_path)
    elif report_type == 'nessus':
        return parse_html_report(report_path)
    else:
        print("Unsupported report type or no report type specified.")
        return "0.00"


# Example calculate_risk_score function (simplified for this example)
def calculate_risk_score(args):
    total_score = 0.0
    reports_processed = 0

    if args.burp_report is not None:
        burp_score = get_report(args.burp_report, report_type='burp')
        total_score += float(burp_score)
        reports_processed += 1
        print(f"Calculated Burp risk score: {burp_score}")

    if args.nessus_report is not None:
        nessus_score = get_report(args.nessus_report, report_type='nessus')
        total_score += float(nessus_score)
        reports_processed += 1
        print(f"Calculated Nessus risk score: {nessus_score}")

    if reports_processed > 0:
        print(f"Total Calculated Risk Score: {total_score}")
    else:
        print("No report provided.")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Process report file and calculate vulnerability scores.")
    parser.add_argument("--burp-report", help="Path to the Burp XML report file")
    parser.add_argument("--nessus-report", help="Path to the Nessus HTML report file")
    args = parser.parse_args()

    calculate_risk_score(args)

